(function() {

    "use strict";

    var _;

    var thunkify = require('fora-node-thunkify'),
        Validator = require('fora-validator');


    var validate = function*(record, typeDefinition, typesService) {
        var validator = new Validator(typesService);
        return yield* validator.validate(record, typeDefinition);
    };



    var findById = function*(typeDefinition, id, context) {
        var query = context.db.setRowId({}, id);
        return yield* findOne(typeDefinition, query, {}, context);
    };



    var find = function*(typeDefinition, query, options, context) {
        if (arguments.length === 3) {
            context = options;
            options = null;
        }

        var db = context.db, typesService = context.typesService;

        var items = yield* db.find(typeDefinition, query, options);
        if (items.length) {
            var results = [];
            for (var _i = 0; _i < items.length; _i++) {
                var item = items[_i];
                results.push(yield* typesService.constructModel(item, typeDefinition));
            }
            return results;
        } else {
            return [];
        }
    };


    var findOne = function*(typeDefinition, query) {
        var options, context;

        if (arguments.length === 3) {
            context = arguments[2];
        } else if (arguments.length === 4) {
            options = arguments[2];
            context = arguments[3];
        }

        var db = context.db, typesService = context.typesService;
        var result = yield* db.findOne(typeDefinition, query, options);
        if (result) {
            return yield* typesService.constructModel(result, typeDefinition);
        }
    };


    var count = function*(typeDefinition, query, context) {
        var db = context.db, typesService = context.typesService;
        return yield* db.count(typeDefinition, query);
    };


    var destroyAll = function*(typeDefinition, query, context) {
        var db = context.db, typesService = context.typesService;

        if (typeof typeDefinition.canDestroyAll === "function" && typeDefinition.canDestroyAll(query)) {
            return yield* db.remove(typeDefinition, query);
        } else {
            throw new Error("Call to destroyAll must pass safety checks on query.");
        }
    };


    var save = function*(record, typeDefinition, context) {
        var db = context.db, typesService = context.typesService;

        if (typeDefinition.autoGenerated) {
            for (var fieldName in typeDefinition.autoGenerated) {
                var def = typeDefinition.autoGenerated[fieldName];
                switch (def.event) {
                    case 'created':
                        if (!db.getRowId(record)) {
                            record[fieldName] = Date.now();
                        }
                        break;
                    case 'updated':
                        record[fieldName] = Date.now();
                }
            }
        }

        var errors = yield* validate(record, typeDefinition, typesService);

        if (!errors.length) {
            if (db.getRowId(record) && (typeDefinition.concurrency === 'optimistic' || !typeDefinition.concurrency)) {
                var _item = yield* findById(typeDefinition, db.getRowId(record), context);
                if (_item.__updateTimestamp !== record.__updateTimestamp) {
                    throw new Error("Update timestamp mismatch. Was " + _item.__updateTimestamp + " in saved, " + record.__updateTimestamp + " in new.");
                }
            }

            record.__updateTimestamp = Date.now();
            record.__shard = typeDefinition.generateShard ? typeDefinition.generateShard(record) : "1";

            var result;
            if (!db.getRowId(record)) {
                if (typeDefinition.logging && typeDefinition.logging.onInsert) {
                    var insertEvent = {
                        type: typeDefinition.logging.onInsert,
                        data: record
                    };
                    db.insert('events', insertEvent);
                }
                result = yield* db.insert(typeDefinition, record);
                result = yield* typesService.constructModel(result, typeDefinition);
            } else {
                if (typeDefinition.logging && typeDefinition.logging.onUpdate) {
                    var updateEvent = {
                        type: typeDefinition.logging.onUpdate,
                        data: record
                    };
                    db.insert('events', updateEvent);
                }
                var query = db.setRowId({}, db.getRowId(record));
                _ = yield* db.update(typeDefinition, query, record);
                result = record;
            }
            return result;

        } else {
            var details;

            if (db.getRowId(record)) {
                details = "Invalid record with id " + (db.getRowId(record)) + " in " + typeDefinition.collection + ".";
            } else {
                details = "Validation failed while creating a new entry in " + typeDefinition.collection + ".";
            }
            details += " " + errors.length + " errors generated at " + (Date().toString('yyyy-MM-dd'));
            details = details + ": " + (errors.join(', ')) + ".";
            throw new Error("Model failed validation. " + details);
        }
    };


    var destroy = function*(record, typeDefinition, context) {
        var db = context.db, typesService = context.typesService;

        var query = db.setRowId({}, db.getRowId(record));
        return db.remove(typeDefinition, query);
    };


    var link = function*(record, typeDef, name, context) {
        var db = context.db, typesService = context.typesService;

        var query, result, _i, _j;

        var link = typeDef.links[name];
        var otherTypeDef = yield* typesService.getTypeDefinition(link.type);
        if (link.key) {
            //#this handles keys of the type [{credentialId: _id}, {username: username}]
            if (typeof link.key === 'string') {
                switch (typeDef.schema.properties[link.key].type) {
                    case 'string':
                        return yield* findById(typeDefinition, record[link.key], context);
                    case 'array':
                        throw new Error("Array keys are not implemented");
                }
            } else if (link.key instanceof Array) {
                query = {};
                link.key.forEach(function(key) {
                    for(var keyFrom of key) {
                        var keyTo = key[keyFrom];
                        query[keyTo] = record[keyFrom];
                    }
                }, record);
                return yield* findOne(otherTypeDef, query, context);
            } else {
                throw new Error("Cannot parse this key");
            }

        } else if (link.field) {
            //handles keys of the type [{credentialId: _id}, {username: username}]
            if (typeof link.field === 'string') {
                switch (otherTypeDef.schema.properties[link.field].type) {
                    case 'string':
                        var params = {};
                        params["" + link.field] = db.getRowId(record);
                        result = yield* find(otherTypeDef, params, context);
                        if (link.multiplicity === "one") {
                            if (result.length) {
                                return result[0];
                            }
                        } else {
                            return result;
                        }
                        break;
                    case 'array':
                        throw new Error("Array keys are not implemented");
                }
            } else if (link.field instanceof Array) {
                query = {};
                link.field.forEach(function(field) {
                    for(var fieldFrom of field) {
                        var fieldTo = field[fieldFrom];
                        query[fieldFrom] = record[fieldTo];
                    }
                }, record);
                return yield* findOne(otherTypeDef, query, context);
            } else {
                throw new Error("Cannot parse this key");
            }

        } else {
            throw new Error("Invalid link " + name + " in " + typeDef.name);
        }
    };


    module.exports = {
        findById: findById,
        find: find,
        findOne: findOne,
        count: count,
        destroyAll: destroyAll,
        save: save,
        destroy: destroy,
        link: link
    };

})();
